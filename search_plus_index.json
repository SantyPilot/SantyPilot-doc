{"./":{"url":"./","title":"简介","keywords":"","body":"SantyPilot 是什么 SantyPilot是一个开源飞控项目，前身是LibrePilotSantyPilot聚焦于教学与科研领域，专注于固定翼与多旋翼性能调优与算法验证通过轻量模块化的框架，和配套的开发规范，方便新手快速上手 SantyPilot官方文档 官方文档链接本项目为SantyPilot官方文档，您可以自由更新其中内容如果您在环境配置，开发，使用过程中遇到任何问题可以到代码仓issue页面将问题描述清楚，附上报错截图，提交给我们搭建本地SantyPilot-doc开发环境 node -v v14.17.0 npm -v 6.14.13 npm install gitbook 您可以按照如下方法构建与更新SantyPilot文档 git clone git@github.com:SantyPilot/SantyPilot-doc.git cd SantyPilot-doc # do some modification gitbook build # build .md files gitbook serve # preview on localhost:4000 git add ./ git commit -m \"ADD NEW FEATURE\" git push origin $YOUR_BRANCH # make a push mkdir ../temp # make a temp dir cp -rf ./_book/* ../temp # cp page files into temp git checkout $YOUR_PAGE_BRANCH # check into your develop branch cp -rf ../temp/* . git add ./ git commit -m \"UPDATE PAGE FILES\" git push origin $YOUR_PAGE_BRANCH # make another push # then make two PR: one $YOUR_BRANCH->dev # the other $YOUR_PAGE_BRANCH->gh-pages 如果遇到如下报错 Installing GitBook 3.2.2 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) 您可以编辑报错文件把报错跳过去 vim /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js 注释掉 62 //fs.stat = statFix(fs.stat) 63 //fs.fstat = statFix(fs.stat) 64 //fs.lstat = statFix(fs.stat) 重新构建即可通过 SantyPilot 生态推广 欢迎关注我们的公众号，了解前沿咨询，构建无人机全栈开发能力 .santynotebook { text-align:center; } 如果您有任何科研教学上的合作或需求，可以发邮件联系我（小新） 邮箱 xiaosanti213@gmail.com 邮箱 963786615@qq.com QQ 963786615 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-20 18:54:13 "},"project/development.html":{"url":"project/development.html","title":"开发环境搭建","keywords":"","body":"Linux（推荐） 环境要求 实际版本可有不同，欢迎补充 lsb_release -a stributor ID: Ubuntu Description: Ubuntu 16.04.6 LTS Release: 16.04 Codename: xenial 下载三方库与构建工具链 添加工具仓，借用librepilot的PPA（Personal Package Archive）仓库 sudo add-apt-repository ppa:librepilot/tools -y sudo apt-get update -q 下载构建工具与三方库 sudo apt-get install build-essential curl ccache debhelper git-core git-doc flex graphviz bison libudev-dev libusb-1.0-0-dev libsdl1.2-dev python libopenscenegraph-dev qt5-default qttools5-dev-tools libqt5svg5-dev qtdeclarative5-dev qml-module-qtquick-controls libqt5serialport5-dev qtmultimedia5-dev qtscript5-dev libqt5opengl5-dev qml-module-qtquick-controls qml-module-qtquick-dialogs qml-module-qtquick-xmllistmodel qml-module-qtquick-localstorage qml-module-qtquick-particles2 qml-module-qtquick-window2 qml-module-qtquick2 libosgearth-dev openscenegraph-plugin-osgearth 下载SantyPilot代码并下载其他工具链 git clone -b dev git@github.com:SantyPilot/SantyPilot.git cd SantyPilot make arm_sdk_install # arm cross toolchain make qt_sdk_install # qt 5.9.0 make gtest_install # unit-test make ccache_install # speed up compile QT安装包文件较大，下载可能较慢，可以用加速器下载链接将安装包qt_opensource-linux-x64-5.9.0.run下载到download目录下执行如下命令安装 sudo chmod +x qt-opensource-linux-x64-5.9.0.run ./qt-opensource-linux-x64-5.9.0.run --script SantyPilot/make/tool_install/qt-install.qs 构建 并发构建地面站软件 make -j8 gcs 构建SantyPilot通信机制uavobjects make -j8 uavobjects 构建整个固件entire flash(ef = bl + fw) make -j8 ef_revolution 出现构建报错，您可以在构建命令里添加V=1选项，打印报错命令，贴给我们 make -j8 V=1 ef_revolution 需要说明的是，revolution为Librepilot已有固件，现在在网上找不到这款飞控了我们的云雾mist系列飞控套件正在抓紧测评中，发布届时更新文档和构建命令，此处仅示意说明 生成的地面站，飞控软件可以在build目录下找到 烧录 推荐您使用如下命令安装st-flash，st-info工具 make stm32flash_install 并添加SantyPilot/tools/stm32flash/build 环境变量方便使用用st-info检查连接状态,运行 st-info --probe 如果可以返回设备连接信息，说明系统连接状态正常推荐使用st-flash，把整个固件（entire flash）烧录到STM32F4 flash程序起始地址 st-flash --reset write build/firmware/ef_revolution/ef_revolution.bin 0x08000000 为了方便，您可以用alias简化命令行 alias flash_image='st-flash --reset write build/firmware/ef_revolution/ef_revolution.bin 0x08000000' 于是，flash_image可以代指整个命令 调试 调试原理： openocd与STLink-STM32 PC端口连接，作为telnet服务器解析并处理telnet客户端发来的指令（如reset, start, halt等）同时openocd作为gdb-server处理gdb调试指令（如break, watch等） 您可以在根目录下执行下面命令，本地下载解压openocd make openocd_install 此时openocd可执行文件解压缩到tools文件夹下，您可配置环境变量或使用alias简化命令行操作，参考上文 确认openocd可用 openocd -v Open On-Chip Debugger 0.9.0 (2018-01-24-01:05) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html 用STLinkV2设备连接飞控SWD口，另一端连接到PC USB端口 启动OpenOCD openocd -f SantyPilot/flight/Project/OpenOCD/stlink.cfg -f SantyPilot/flight/Project/OpenOCD/stm32f4x.cfg Open On-Chip Debugger 0.11.0 Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html WARNING: interface/stlink-v2-1.cfg is deprecated, please switch to interface/stlink.cfg Info : auto-selecting first available session transport \"hla_swd\". To override use 'transport select '. Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections Info : clock speed 2000 kHz Info : STLINK V2J37M27 (API v2) VID:PID 0483:374B Info : Target voltage: 3.240865 Info : stm32g0x.cpu: hardware has 4 breakpoints, 2 watchpoints Info : starting gdb server for stm32g0x.cpu on 3333 Info : Listening on port 3333 for gdb connections 新打开一个终端，运行telnet命令，启动客户端，用来发送基本指令并在telnet状态下，和openocd建立连接 telnet telnet> o localhost 4444 此时再新打开一个终端 启动gdb，并在gdb状态下和gdb-server(openocd)连接 arm-none-eabi-gdb SantyPilot/build/firmware/fw_revolution/fw_revolution.elf gdb> target remote: 3333 如果您是初学者，我们非常推荐这种方式调试开发，一方面商用友好，另外熟练下来命令行操作比IDE点选要快很多，而且Linux系统对三方库管理也相对稳定 仿真 您可以用如下命令构建仿真程序 make -j8 simposix Windows 环境要求 Win7,Win8,Win10 下载三方库与构建工具链 您可以在链接下载i686（32bit）或x86_64（64bit）MSYS2，并安装其中包含了GNU构建工具链，必要的命令行工具，以及pacman包管理系统 打开MSYS2终端工具，添加pacman三方库地址，这里使用librepilot提供的pacman地址 echo \"[librepilot-mingw]\" >> /etc/pacman.conf echo \"SigLevel = Optional TrustAll\" >> /etc/pacman.conf echo \"Server = http://download.librepilot.org/repo/mingw\" >> /etc/pacman.conf 可以打开地址http://download.librepilot.org/repo/mingw查看其中的包文件然后打开MINGW32终端，更新配置并下载所需三方库，其中--needed表示若有新版，不更新覆盖本地旧版本 pacman -Sy pacman -S --needed git unzip tar pacman -S --needed mingw-w64-i686-toolchain pacman -S --needed mingw-w64-i686-ccache pacman -S --needed mingw-w64-i686-ntldd pacman -S --needed mingw-w64-i686-qt5 pacman -S --needed mingw-w64-i686-SDL pacman -S --needed mingw-w64-i686-mesa pacman -S --needed mingw-w64-i686-openssl pacman -S --needed mingw-w64-i686-gdal-minimal pacman -S --needed mingw-w64-i686-OpenSceneGraph pacman -S --needed mingw-w64-i686-osgearth pacman -S --needed mingw-w64-i686-graphite2 pacman -S --needed mingw-w64-i686-nghttp2 pacman -S --needed mingw-w64-i686-gst-plugins-base pacman -S --needed mingw-w64-i686-gst-plugins-good pacman -S --needed mingw-w64-i686-gst-plugins-bad pacman -S --needed mingw-w64-i686-gst-plugins-ugly pacman -S --needed mingw-w64-i686-gst-libav 或是MINGW64终端 pacman -Sy pacman -S --needed git unzip tar pacman -S --needed mingw-w64-x86_64-toolchain pacman -S --needed mingw-w64-x86_64-ccache pacman -S --needed mingw-w64-x86_64-ntldd pacman -S --needed mingw-w64-x86_64-qt5 pacman -S --needed mingw-w64-x86_64-SDL pacman -S --needed mingw-w64-x86_64-mesa pacman -S --needed mingw-w64-x86_64-openssl pacman -S --needed mingw-w64-x86_64-gdal-minimal pacman -S --needed mingw-w64-x86_64-OpenSceneGraph pacman -S --needed mingw-w64-x86_64-osgearth pacman -S --needed mingw-w64-x86_64-gst-plugins-base pacman -S --needed mingw-w64-x86_64-gst-plugins-good pacman -S --needed mingw-w64-x86_64-gst-plugins-bad pacman -S --needed mingw-w64-x86_64-gst-plugins-ugly pacman -S --needed mingw-w64-x86_64-gst-libav 下载代码并下载工具链 git clone -b dev git@github.com:SantyPilot/SantyPilot.git cd SantyPilot mingw32-make arm_sdk_install # arm cross toolchain mingw32-make qt_sdk_install # qt 5.9.0 mingw32-make gtest_install # unit-test mingw32-make ccache_install # speed up compile 需要注意的是，MINGW环境下，构建用mingw32-make 遇到QT下载慢的问题，可以参考Linux的解决办法，不赘述 构建 构建命令与Linux相同，可参考上文，此处不赘述 烧录 烧录可以使用st-utility UI版本烧录工具，将ef_revolution.bin烧录到0x08000000地址这里和Linux的烧录方法本质相同，不赘述 调试 调试方案也是采用STLink硬件 + OpenOCD + GDB的方式需要说的是，微软推出Windows Terminal，可以获得和Linux一样的操作体验如果您更喜欢IDE方式，可以使用VSCode + json配置文件方式改进调试体验这里提供一份launch.json调试脚本模板 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"debug santypilot\", \"program\": \"E:\\\\SantyPilot\\\\build\\\\firmware\\\\fw_revolution\\\\fw_revolution.elf\", \"miDebuggerServerAddress\": \"127.0.0.1:3333\", \"cwd\":\"E:\\\\SantyPilot\", \"miDebuggerPath\":\"E:\\\\SantyPilot\\\\tools\\\\gcc-arm-none-eabi-4_9-2015q2\\\\bin\\\\arm-none-eabi-gdb.exe\" } ] } 仿真 目前还不支持Windows上的仿真程序，正在支持开发中 开发规范 希望您遵守如下开发规范 工具安装 make doxygen_install # win: mingw32-make make uncrustify_install 开发流程 您Fork一份到本人仓库，单一功能开发或BUG修复完成后，先提交到本人仓库，再提交Push Request(PR)到SantyPilot主仓英文说明功能，场景，最好附上自测截图，团队内开发review代码后合入优秀代码合入将会收到红包奖励 编码规范 希望您使用英文注释，简单说清含义即可另外，推荐您遵守Google Code Style Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"software/arch.html":{"url":"software/arch.html","title":"架构","keywords":"","body":"软件架构 嵌入式层 STM32驱动与微内核 采用FreeRTOS微内核，支持多种外设STM32驱动，自定义新增传感器相对简单 flight/pios文件夹 . ├── pios.h ├── inc ├── osx ├── common/ 通用设备驱动 | ├── libraries 文件系统，微内核 | |── pios_sensors.c 传感器封装 | └── ... | └── stm32f4xx/ 型号特定驱动 ├── link_STM32F4xx_RM_fw_memory.ld 链接脚本指定内存布局 |── libraries CMSIS, USB库 └── pios_i2c.c 协议封装 flight/targets/boards/revolution文件夹 . ├── boad_hw_defs.c 硬件引脚配置 ├── firmware/ ├── revolution.cpp 入口主函数 |── pios_board.c 驱动初始化 └── inc/ |── pios_config.h 驱动剪裁宏 外设选择 应用层 通信机制 uavobject是类似于uORB的轻量级通信机制，而与PX4不同的是，uavobject也用于飞控与地面站通信，而PX4采用MAVLink uavo消息由XML定义，您可以参考shared/uavobjectdefinition了解全部消息定义生成的源码则文件位于 build/uavobject-synthetics/如果您对xml->src机制感兴趣，可以参考ground/uavobjgenerator 对于应用层业务模块间通信,机制上得益于FreeRTOS的msg queue而接口层面依赖于flight/uavobjects定义的一些接口您也可以参考flight/Example了解其用法和场景 对于地面站通信，无论是有线还是无线，在硬件驱动层面都做了抽象您可以参考flight/uavobjects了解消息的序列化和反序列化flight/uavtalk是处理消息的一些工具封装 应用模块 得益于微核调度和通信机制的封装应用层的业务模块可以实现隔离 为了满足不同场景调度需求，当前支持普通task，DelayCallback等您可以参考flight/Example和CallbackTest了解它们的使用方法 您也可以参考如下模块了解自定义模块开发流程 模块 描述 Actuator 计算电机输出 FlightPlan 航路点路径规划 FirmwareIAP 板子型号认证 GPS GPS传感器 Logging 日志操作控制 ManualControl 手动输入信号控制 Receiver 接收机信号处理 Sensors 传感器数据整合 Stabilization 姿态控制器 StateEstimation EKF状态估计 模块性能 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"software/filter.html":{"url":"software/filter.html","title":"滤波","keywords":"","body":"滤波原理 采用EKF做状态估计 关于EKF与PX4实现的相关背景知识您可以参考链接 变量设计 状态向量为 x=[pN,pE,pD,vN,vE,vD,q0,q1,q2,q3,gbx,gby,gbz]Tx=\\left[\\begin{array}{l} p_{N}, p_{E}, p_{D}, v_{N}, v_{E}, v_{D}, q_{0}, q_{1}, q_{2}, q_{3}, gb_{x}, gb_{y}, gb_{z} \\end{array}\\right]^Tx=[​p​N​​,p​E​​,p​D​​,v​N​​,v​E​​,v​D​​,q​0​​,q​1​​,q​2​​,q​3​​,gb​x​​,gb​y​​,gb​z​​​​]​T​​ 其中分量分别为 地系位置(position) 地系速度(velocity) 姿态四元数(quaternion) 陀螺仪机体系偏移量(gyro bias) 惯性测量作为输入量 u=[gx,gy,gz,ax,ay,az]Tu=\\left[\\begin{array}{l} g_{x}, g_{y}, g_{z}, a_{x}, a_{y}, a_{z} \\end{array}\\right]^Tu=[​g​x​​,g​y​​,g​z​​,a​x​​,a​y​​,a​z​​​​]​T​​ 和其他传感器分别融合，部分观测向量为 y=[pN,pE,pD,vN,vE,vD,magx,magy,magz,baro]Ty=\\left[\\begin{array}{l} p_{N}, p_{E}, p_{D}, v_{N}, v_{E}, v_{D}, mag_{x}, mag_{y}, mag_{z}, baro \\end{array}\\right]^Ty=[​p​N​​,p​E​​,p​D​​,v​N​​,v​E​​,v​D​​,mag​x​​,mag​y​​,mag​z​​,baro​​]​T​​ 先验估计 先验估计包括状态预测和系统噪声协方差预测 状态预测 状态预测是结合状态微分方程，估计k+1k+1k+1时刻状态，源码RungeKutta法 Xk+1−=f(Xk,Uk)X_{k+1}^{-} = f(X_{k}, U_{k})X​k+1​−​​=f(X​k​​,U​k​​) 和PX4不同，这里没有各新息数据到来时分批处理，而是只运行一次预测 其中地系速度由机体加速度经过四元数旋转得到，新的四元数由前时刻四元数经过机体角速度旋转得到 系统误差协方差预测 系统误差协方差预测需要把非线性方程线性化，计算对时间一阶导和状态偏分 包括状态变换矩阵FFF与系统噪声传递矩阵GGG F阵线性化 地系位置对地系速度 为单位阵 地系速度对四元数 ∂f˙v∂q=[2(q0ax−q3ay+q2az)2(q1ax−q2ay+q3az)2(q2ax+q1ay+q0az)2(q3ax−q0ay+q1az)2(q3ax+q0ay−q1az)2(q2ax−q1ay−q0az)2(q1ax+q2ay+q3az)2(q0ax−q3ay+q2az)2(−q2ax+q1ay+q0az)2(q3ax+q0ay−q1az)2(−q0ax+q3ay−q2az)2(q1ax+q2ay+q3az)]\\frac{\\partial \\dot f_{v}}{\\partial q}=\\left[\\begin{array}{cccc} 2\\left(q_{0}a_{x}-q_{3}a_{y}+q_{2}a_{z}\\right) & 2\\left(q_{1}a_{x}-q_{2}a_{y}+q_{3}a_{z}\\right) & 2\\left(q_{2}a_{x}+q_{1}a_{y}+q_{0}a_{z}\\right) & 2\\left(q_{3}a_{x}-q_{0}a_{y}+q_{1}a_{z}\\right) \\\\ 2\\left(q_{3}a_{x}+q_{0}a_{y}-q_{1}a_{z}\\right) & 2\\left(q_{2}a_{x}-q_{1}a_{y}-q_{0}a_{z}\\right) & 2\\left(q_{1}a_{x}+q_{2}a_{y}+q_{3}a_{z}\\right) & 2\\left(q_{0}a_{x}-q_{3}a_{y}+q_{2}a_{z}\\right) \\\\ 2\\left(-q_{2}a_{x}+q_{1}a_{y}+q_{0}a_{z}\\right) & 2\\left(q_{3}a_{x}+q_{0}a_{y}-q_{1}a_{z}\\right) & 2\\left(-q_{0}a_{x}+q_{3}a_{y}-q_{2}a_{z}\\right) & 2\\left(q_{1}a_{x}+q_{2}a_{y}+q_{3}a_{z}\\right) \\end{array}\\right]​∂q​​∂​f​˙​​​v​​​​=​⎣​⎡​​​2(q​0​​a​x​​−q​3​​a​y​​+q​2​​a​z​​)​2(q​3​​a​x​​+q​0​​a​y​​−q​1​​a​z​​)​2(−q​2​​a​x​​+q​1​​a​y​​+q​0​​a​z​​)​​​2(q​1​​a​x​​−q​2​​a​y​​+q​3​​a​z​​)​2(q​2​​a​x​​−q​1​​a​y​​−q​0​​a​z​​)​2(q​3​​a​x​​+q​0​​a​y​​−q​1​​a​z​​)​​​2(q​2​​a​x​​+q​1​​a​y​​+q​0​​a​z​​)​2(q​1​​a​x​​+q​2​​a​y​​+q​3​​a​z​​)​2(−q​0​​a​x​​+q​3​​a​y​​−q​2​​a​z​​)​​​2(q​3​​a​x​​−q​0​​a​y​​+q​1​​a​z​​)​2(q​0​​a​x​​−q​3​​a​y​​+q​2​​a​z​​)​2(q​1​​a​x​​+q​2​​a​y​​+q​3​​a​z​​)​​​⎦​⎤​​ 四元数对四元数 并用小角度三角函数近似为 ∂f˙q∂q=[0−ωx2−ωy2−ωz2ωx20ωz2−ωy2ωy2−ωz20ωx2ωz2ωy2−ωx20]\\frac{\\partial \\dot f_{q}}{\\partial q}=\\left[\\begin{array}{cccc} 0 & -\\frac{\\omega_{x}}{2} & -\\frac{\\omega_{y}}{2} & -\\frac{\\omega_{z}}{2} \\\\ \\frac{\\omega_{x}}{2} & 0 & \\frac{\\omega_{z}}{2} & -\\frac{\\omega_{y}}{2} \\\\ \\frac{\\omega_{y}}{2} & -\\frac{\\omega_{z}}{2} & 0 & \\frac{\\omega_{x}}{2} \\\\ \\frac{\\omega_{z}}{2} & \\frac{\\omega_{y}}{2} & -\\frac{\\omega_{x}}{2} & 0 \\end{array}\\right]​∂q​​∂​f​˙​​​q​​​​=​⎣​⎢​⎢​⎡​​​0​​2​​ω​x​​​​​​2​​ω​y​​​​​​2​​ω​z​​​​​​​−​2​​ω​x​​​​​0​−​2​​ω​z​​​​​​2​​ω​y​​​​​​​−​2​​ω​y​​​​​​2​​ω​z​​​​​0​−​2​​ω​x​​​​​​​−​2​​ω​z​​​​​−​2​​ω​y​​​​​​2​​ω​x​​​​​0​​​⎦​⎥​⎥​⎤​​ 四元数对陀螺仪角速度偏移量 来自四元数更新方程，不赘述 G阵线性化 考虑系统误差向量 Qx=[gx,gy,gz,ax,ay,az,gbx,gby,gbz]TQ_{x}=\\left[\\begin{array}{l} g_{x}, g_{y}, g_{z}, a_{x}, a_{y}, a_{z}, gb_{x}, gb_{y}, gb_{z} \\end{array}\\right]^TQ​x​​=[​g​x​​,g​y​​,g​z​​,a​x​​,a​y​​,a​z​​,gb​x​​,gb​y​​,gb​z​​​​]​T​​ 考虑系统误差传递矩阵GGG，描述部分状态变量存在系统误差，对其他状态分量传递作用 四元数来自陀螺仪角速度的影响 ∂f˙q∂gyro=[q12q22q32−q02q32−q22−q32−q02q12q22−q12−q02]\\frac{\\partial \\dot f_{q}}{\\partial gyro}=\\left[\\begin{array}{ccc} \\frac{q_{1}}{2} & \\frac{q_{2}}{2} & \\frac{q_{3}}{2} \\\\ -\\frac{q_{0}}{2} & \\frac{q_{3}}{2} & -\\frac{q_{2}}{2} \\\\ -\\frac{q_{3}}{2} & -\\frac{q_{0}}{2} & \\frac{q_{1}}{2} \\\\ \\frac{q_{2}}{2} & -\\frac{q_{1}}{2} & -\\frac{q_{0}}{2} \\end{array}\\right]​∂gyro​​∂​f​˙​​​q​​​​=​⎣​⎢​⎢​⎡​​​​2​​q​1​​​​​−​2​​q​0​​​​​−​2​​q​3​​​​​​2​​q​2​​​​​​​​2​​q​2​​​​​​2​​q​3​​​​​−​2​​q​0​​​​​−​2​​q​1​​​​​​​​2​​q​3​​​​​−​2​​q​2​​​​​​2​​q​1​​​​​−​2​​q​0​​​​​​​⎦​⎥​⎥​⎤​​ 四元数来自加速度计的影响 ∂f˙q∂acc=[(−q02−q12+q22+q32)2(−q1a2+q0q3)−2(q1q3+q0q2)−2(q1q2+q0q3)(−q02+q12−q22+q32)2(−q2q3+q0q1)2(−q1q3+q0q2)−2(q2q3+q0q1)(−q02+q12+q22−q32)]\\frac{\\partial \\dot f_{q}}{\\partial acc}=\\left[\\begin{array}{ccc} \\left(-q_{0}^2-q_{1}^2+q_{2}^2+q_{3}^2\\right) & 2\\left(-q_{1}a_{2}+q_{0}q_{3}\\right) & -2\\left(q_{1}q_{3}+q_{0}q_{2}\\right) \\\\ -2\\left(q_{1}q_{2}+q_{0}q_{3}\\right) & \\left(-q_{0}^2+q_{1}^2-q_{2}^2+q_{3}^2\\right) & 2\\left(-q_{2}q_{3}+q_{0}q_{1}\\right) \\\\ 2\\left(-q_{1}q_{3}+q_{0}q_{2}\\right) & -2\\left(q_{2}q_{3}+q_{0}q_{1}\\right) & \\left(-q_{0}^2+q_{1}^2+q_{2}^2-q_{3}^2\\right) \\end{array}\\right]​∂acc​​∂​f​˙​​​q​​​​=​⎣​⎡​​​(−q​0​2​​−q​1​2​​+q​2​2​​+q​3​2​​)​−2(q​1​​q​2​​+q​0​​q​3​​)​2(−q​1​​q​3​​+q​0​​q​2​​)​​​2(−q​1​​a​2​​+q​0​​q​3​​)​(−q​0​2​​+q​1​2​​−q​2​2​​+q​3​2​​)​−2(q​2​​q​3​​+q​0​​q​1​​)​​​−2(q​1​​q​3​​+q​0​​q​2​​)​2(−q​2​​q​3​​+q​0​​q​1​​)​(−q​0​2​​+q​1​2​​+q​2​2​​−q​3​2​​)​​​⎦​⎤​​ 则 Pk+1−=FkPkFkT+GkQkGkTP_{k+1}^{-}=F_{k} P_{k} F_{k}^{T}+G_{k} Q_{k} G_{k}^{T}P​k+1​−​​=F​k​​P​k​​F​k​T​​+G​k​​Q​k​​G​k​T​​ 后验校正 其他传感器数据到来，结合观测方程对先验估计做校正 计算卡尔曼增益 Kk+1=Pk−HkT(HkPk−HkT+Vk)K_{k+1}=P_{k}^{-} H_{k}^{T}(H_{k} P_{k}^{-} H_{k}^{T} + V_{k})K​k+1​​=P​k​−​​H​k​T​​(H​k​​P​k​−​​H​k​T​​+V​k​​) 这里对观测方程非线性hhh函数做线性化，思路同上可参考代码 不赘述 后验估计状态 Xk+1=Xk−+Kk(yk−h(Xk−,Uk))X_{k+1}=X_{k}^{-} + K_{k} (y_{k}-h(X_{k}^{-}, U_{k}))X​k+1​​=X​k​−​​+K​k​​(y​k​​−h(X​k​−​​,U​k​​)) 后验估计系统噪声协方差 Pk+1=(I−KkHk)Pk−P_{k+1}=(I - K_{k} H_{k}) P_{k}^{-}P​k+1​​=(I−K​k​​H​k​​)P​k​−​​ Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"software/control.html":{"url":"software/control.html","title":"控制","keywords":"","body":"控制原理 四旋翼飞行状态规律 四旋翼是一个欠驱动系统。它的前后、左右、上下、左右旋转飞行依赖于姿态俯仰、滚转、油门变化、偏航来进一步完成 通常，电机产生的拉力与其转速为平方正比关系，即某个电机产生的拉力可以表达为T=cTω~2T=c_T\\tilde{\\omega}^2T=c​T​​​ω​~​​​2​​。 其中常量cTc_Tc​T​​是一个转化率，显然与螺旋桨效率有关 根据X四旋翼的几何关系，将力矩代入，有 [ϕ¨θ¨ψ¨T]=[k−k−kkkk−k−kk−kk−kkkkk][ϖ12ϖ22ϖ32ϖ42]\\left[\\begin{array}{c} \\ddot{\\phi} \\\\ \\ddot{\\theta} \\\\ \\ddot{\\psi} \\\\ T \\end{array}\\right]=\\left[\\begin{array}{cccc} k & -k & -k & k \\\\ k & k & -k & -k \\\\ k & -k & k & -k \\\\ k & k & k & k \\end{array}\\right]\\left[\\begin{array}{c} \\varpi_{1}^{2} \\\\ \\varpi_{2}^{2} \\\\ \\varpi_{3}^{2} \\\\ \\varpi_{4}^{2} \\end{array}\\right]​⎣​⎢​⎢​⎡​​​​ϕ​¨​​​​θ​¨​​​​ψ​¨​​​T​​​⎦​⎥​⎥​⎤​​=​⎣​⎢​⎢​⎡​​​k​k​k​k​​​−k​k​−k​k​​​−k​−k​k​k​​​k​−k​−k​k​​​⎦​⎥​⎥​⎤​​​⎣​⎢​⎢​⎡​​​ϖ​1​2​​​ϖ​2​2​​​ϖ​3​2​​​ϖ​4​2​​​​​⎦​⎥​⎥​⎤​​ 如下为典型X型四旋翼示意图 可见，1，2电机一组，3，4电机一组，组内同时提高/降低转速可以实现俯仰运动； 1，4电机一组，2，3电机一组，可以实现滚转运动； 1，3一组，2，4一组，则可以实现偏航运动； 四个电机同时提高（降低）转速则飞行器向上（向下）运动 PID控制器 使用比例-积分-微分控制器完成对线性模型控制 u(t)=Kpe(t)+Ki∫0te(τ)dτ+Kdddte(t)u(t)=K_{p} e(t)+K_{i} \\int_{0}^{t} e(\\tau) d \\tau+K_{d} \\frac{d}{d t} e(t)u(t)=K​p​​e(t)+K​i​​∫​0​t​​e(τ)dτ+K​d​​​dt​​d​​e(t) 其中 e(t)e(t)e(t)为当前时刻的误差 KpK_pK​p​​,KiK_iK​i​​,KdK_dK​d​​为比例积分微分增益 u(t)u(t)u(t)计算结果作为控制量输入给系统 增益需要调试确定 比例系数可以用来加快调节，但是过大会引起系统响应幅度过大，甚至不稳定 积分项用来减少稳态误差，但是过大会引起系统迟滞 微分项是瞬态的考量，可以预测误差变化趋势，但是过大会引起系统过于敏感 采用串级PID（Cascading PID）以达到更好的控制效果。 外环控制角度， 内环控制角速度，如下图 .copter { text-align:center; } Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"software/command.html":{"url":"software/command.html","title":"指令","keywords":"","body":"指令系统 指令系统用于飞行模式切换，飞行路径规划，设置控制目标值 . ├── Receiver/ 调用驱动接口获取遥控器指令 ├── ManualControl/ 处理遥控器指令，模式切换 | ├── armhandler.c 解锁上锁检查 | |── pathplannerhandler.c | |── pathfollower.c | └── ... | |── FlightPlan/ 飞行计划状态，控制 |── Stabilization/ 姿态控制 |── PathPlanner/ 路径点切换，设置飞行路径 └── PathFollower/ ├── pathfollower.cpp 根据机型切换执行逻辑 |── pidcontrole.cpp 位置控制，速度控制封装 |── vtolautotakeoffcontroller.cpp |── vtolautotakeofffsm.cpp 起飞动作分为慢启动，拉升，稳定内部状态机切换 |── vtolflycontroller.cpp |── vtollandcontroller.cpp |── vtollandfsm.cpp └── ... 飞行模式 自主模式 最常见的自主飞行模式，用户通过地面站设置路径点 飞控运行规划逻辑控制飞行器按照预期航线飞行，实现 逻辑 在大地坐标系下，几个关键点位置关系如上图所示，其中 红色为用户设置路径点，红色星号为起飞点，圆圈为一般路径点，飞行器逆时针绕圈飞行 绿色为某瞬时飞行器所在位置，为了方便理解，图中标注惯性系与坐标原点OOO OA⃗\\vec{OA}​OA​⃗​​为起飞点矢量 AB⃗\\vec{AB}​AB​⃗​​为预期航线 OC⃗\\vec{OC}​OC​⃗​​为飞行器某瞬时位矢。显然，它偏离了预期路径 DDD为飞行器位置在预期航线的投影点，OD⃗\\vec{OD}​OD​⃗​​为其位矢 则位置环控制目标点由CD⃗\\vec{CD}​CD​⃗​​定义 位置控制由两个PID环路完成， 外环控制位置， 内环控制速度 内环路输出作为姿态目标，输出给增稳模块，保证运动稳定 手动增稳 手动模式是用户操纵微调，作为姿态环参考点 模式切换 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"software/inter.html":{"url":"software/inter.html","title":"交互","keywords":"","body":"交互 飞控地面站交互 飞控与上位机支持如下两种方式交互 USB接口 TSLink无线数传 飞控数据记录 操作流程 数据分析 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"gcs/arch_gcs.html":{"url":"gcs/arch_gcs.html","title":"机制","keywords":"","body":"软件架构 地面站软件采用插件方式开发 ground/gcs/src路径 . ├── app 入口函数 ├── libs 公用库函数 ├── plugins/ 插件合集 | |── coreplugin 核心插件 | ├── flightlog 飞行日志 | └── ... | └── shared 自定义插件开发 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-07 22:34:30 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"GitBook GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，GitBook 并非关于 Git 的教程。 Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Copyright SantyPilot Team 2024 all right reserved，powered by Gitbook文件最近一次修订时间： 2024-01-01 05:44:47 "}}